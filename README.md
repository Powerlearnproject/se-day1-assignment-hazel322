# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
 it is the application of engineering principles, methods, and tools to develop and maintain high-quality software systems

Identify and describe at least three key milestones in the evolution of software engineering.
1. Structured Programming (1960s)
Introduced principles of modularity, hierarchy, and control flow.
Enabled the development of larger and more complex software systems.

2. Object-Oriented Programming (1970s)
In the early days of programming, software was typically written in a procedural or structured manner, where programs were composed of sequences of instructions that manipulated data. However, as software systems grew in complexity, it became increasingly difficult to manage, maintain, and extend them. This led to the development of the Object-Oriented Programming paradigm.

3. Agile Development (1990s)
Emphasizes iterative development, customer feedback, and adaptability.
Allows for faster and more flexible software development responding to changing requirements.

List and briefly explain the phases of the Software Development Life Cycle.
1. Analysis
   dueing this phase, the project team gathers requirements and expectations from clients, stakeholders and analysts through surveys, meetings and interviews for better         unederstanding of the end goals. During this time, feasiability, risk and impact of the project are analyzed
2. System design
   In this phase, the system's architechture is designed that specify the details of individual componets. Selection of programming language, database and creation of           interface design is done at this stage.
3. Implimentation
   This is where the actual cosing happens. Programming languages are used and design is converted into functional software. 
4. testing
  After coding, the software is tested to ensure that it meets the specified requirements. This includes unit testing, integration testing, system testing, and acceptance       testing. The goal is to find and fix any defects or bugs.
6. Deployment
   Once testing is done and the product is deemed worthy, it is handed over to the clients for use. Some other activities happening dueing this period are software              installation, trainning and moving of data.
7. Maintainance
   Monitoring, updating, changes and additions are done in this phase according to client's desire
   
Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
Waterfall method is a traditional approach to software development where linear processes are followed and without completion of one phase the project cannot move to another phase while the agile method is a development method that was developed to deal with the lack of flexibility in waterfall method by being collaborative, flexible and customer centered. Here are some comparisons and contrasts:
1. Documentation
   In waterfall, detailed documentation is done at every stage of the process and is a requirement for moving to the next stage or phase while agile method requires little      documentation and is done only when necessary since the focus is on the development of the software
2. Flexibility and adaptability
   Waterfall is rigid to changes and is not so accomodative since procedure must be followed regardless. Agile on the other hand is very flexible, changes can be made at any    point and the project evolves according to feedback and desire of client
3. Customer involvement
   Waterfall metod limits customer involvement, only at the beginning during design and at the end after implimentation while agile method encourages custmer involvement at     any stage to ensure tat the project evolves according to customer needs.
4. Development process
   Waterfall follows a linear and structured path regardless while agile is broken down into small interractive segments but without a distinct phase structure
5. Delivery
   Waterfall method allows delivery only on the final stage after completion of project while with agile, the customer can begin benefitting from the software earlier in the 
   process
6. Testing
   Waterfall does late testing after implimentation phase while agile tests the software at any stage of the project.
   

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
1. Software engineer
   - software engineers are responsible for writing efficient and managable codes based on design using programming languages
   - they communicate and collaborate with team members, stakeholders and clients for feedback and progress
   - testing and debugging code
   - review code written by peers to ensure it is up to standard, fix reported bugs
   - create and maintain technical documentation, includING code comments, user guides and API. Document changes and update to code database
  2. Quality assurance engineer
     - Deevelop detailed scripts based on clinet requirement and desired speciifications.
     - perform manual and automated tasks to ensure software's functionality, performance and security while documenting results
     - log and track defects and troubleshoot while documenting.
     - test automation and quality improvement
  3. Project Manager
     - Defines project and objectives in details with timelines, milestones and resource allocation
     - asiign duties to team members utilizing their strengths and expertise
     - Risk management, identify potential risk and impliment mitigating strategies
     - Track project progress aganist the plan to coordinate deployment in time and in the right form.
     - engage with stakeholders concerning expectations, funding and feedback. 

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
1. Intergrated Development Environment
   - provide central developmnet tools, most IDEs combine various functions into a single interface including code editor, VCS, compiler, debugger and more, making               development process more streamlined since time is not wated moving from one interface to another. Example VS code- it is lightweight and extensive and hence productivity
   - Enhanced productivity. the added functions reduce likelihood of errors and speed up development process. they often include project managemnt tools, version control,         intergation and build automation. example pycharm for python provides features like error detection and code navigation
   - debugging and testing tools. IDE often provide debugging tools that allow for code inspection and suggestion for possible debugging suggestion and steps. example.
   - maintaining code quality and refactoring through features like refactoring tools, linting and codestyle enforcement eg webstoem in javascript.

2. Importances of Version Control Systems
   - Collaboration and teamwork allow developers to work on the same project simultaneously while tracking everyone's contributions and managing changes fostering                  collaboration. eg. git, allows developers have full copy of project history facilitating branching and offline mode
   - accountability. Since one can track history of project and who made what changes and when, it makes accountability easier eg.mercurial
   - branching and merging. Changes can be made separately and individually and later merged into the main codebase eg github.
   - Backup and recovery. Acts as a backup system allowing developers recover previous versions incase of a problem ensuring that code is never permanently lost. Due to           recorded history of activities, it is possible to track history of code before the problem. eg. gitlab

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
1. communication and collaboration especially in big teams and remote teams can be challanging due to difference in timezones and merging of different people together, mostly because techies are stereotyped as introverts.
   - this can be resolved by organising team building activities, collaboration platforms like slack and regular meetings.
2. Burn outs especially as deadline approach or even when the project is too demanding.
   - this can be resolved by setting clear boundaries of work time, taking a break and engaging in leisure activities
3. security and privacy concerns, the techspace is constantly evolving and so are malwares, viruses and phishing techniques
   - this can be combatted by using best practice, using encription and two step verification of data. also by not using public wifi when dealing with sensitive data and         also designing secure systems
4. ambigous and indecisive clients who don't communicate clearly their desire or change mind so often.
   - clarify requirement by use of mockups and models with clients, documenting changes and using agile method to ensure agreement on advancement with clients.
5.   Quality delivery under short deadlines
   - by being frank with clients concerning expected durstion of work, using peers to review your code and automated testing, it will reduce issues of colliding with             clients in time and quality delivery.
6. keeping up wih rapid technology changes
   - selective adoption of technology that is specific to one reduces the pressure to know everything that might not necessarily be of use. by learning continously, it           helps one keep up with trends and be ahead.
7. debugging
   - use of automated debugging tools reduces time spent on debugging and channels it to actual progress of software. Peer reviews are highly encouraged since fresh pair of eyes can be helpful.
Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
Unit testing
- this involves testing of individual code units or function separate from the whole system. Some of the functions of unit testing are:
  1. By testing individual codes, there is general improvement of code in the codebase ensuring making changes is made easier
  2. During this phase, there is documentation of how individual codes are supposed to work or function therefore making it easy to follow and pick up from
  3. This testing enables early bug detection since it is done early in the development process.
Intergration  testing
- this involves testing the interraction between different units to ensure they work together as expected. This is when merging of codes happens. Some of the importances of this phase are:
  1. early detection of issues during the development process therefore saving on time that would otherwise be wasted tracing and fixing an even bigger issue.
  2. detection and correction of intergration issues early such as mismatched data formats.
System testing
- this process involves validation of the complete software to ensure it meets specific requirements. Some of the iportances of this process are:
  1. validates the entire system from performace to functionality to security and compliance with business requirements
  2. covers both functional and non functional testing to ensure the system performs well under different conditions.
  3. testing of user experience.
Acceptance testing
- also known as user acceptance testing, this is the final testing phase where the software is tested in the real world scenario by end users and stakeholders.Some importances of this phase are:
1. the software is tested aganist the requirements ensuring it fulfills the business requirements and satisfied customer needs
2. this is where the final approval happens after customer expresses satisfaction indicating that the software is ready for use 
#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.
Promt engineering is the crafting and giving of instructions in a specific and clear manner to AI in order to obtain desired output.
Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
vague promt: tell me about digestion 
clear, specific and concise prompt: explain to me the process of digestion of proteins in human beings from ingestion to absorption naming all organs and enzymes involved. 
